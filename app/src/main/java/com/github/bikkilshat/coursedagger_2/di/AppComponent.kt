package com.github.bikkilshat.coursedagger_2.di

import com.github.bikkilshat.coursedagger_2.MainActivity
import dagger.Component

/***
 * После создания класса App
 * Нам остается рассказать компоненту, какие именно объекты мы хотим от него получать.
 * Для этого мы будем наполнять его интерфейс методами.
 * И вот тут у нас есть два вида методов:
 */

//Нам от компонента нужны объекты DatabaseHelper и NetworkUtils. Для этого нам надо просто добавить
// в интерфейс компонента методы, которые будут возвращать эти объекты:
@Component(modules = [StorageModule::class, NetworkModule::class])
interface AppComponent {

  //Inject метод
  fun injectMainActivity(mainActivity: MainActivity)
  /*
  Вместо пары get-методов мы описываем один inject-метод.
  Имя может быть любым, главное - это тип его единственного параметра.
  Мы указываем здесь MainActivity. Тем самым, мы говорим компоненту, что когда
  мы будем вызывать этот метод и передавать туда экземпляр MainActivity,
  мы ожидаем, что компонент наполнит этот экземпляр требуемыми объектами.
   */

}


/*
Inject метод
У нас в MainActivity сейчас всего два объекта, которые мы получаем от компонента.
Но если их будет штук 20, то придется в интерфейсе компонента описать 20 get-методов
и в коде MainActivity написать 20 вызовов этих методов.
У даггера есть более удобное решение для таких случаев.
Мы можем научить компонент не возвращать объекты, а самому наполнять Activity требуемыми объектами.
Т.е. мы даем компоненту экземпляр MainActivity, а он смотрит, какие объекты нужны, создает их и сам
помещает в соответствующие поля.

Разумеется, get-методы и inject-методы могут быть использованы вместе в одном компоненте.
Автор описывал их отдельно друг от друга только для простоты понимания.
 */